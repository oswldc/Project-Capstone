# -*- coding: utf-8 -*-
"""app_v2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17DMgUBKrqg9pxu10WoIEA3AG-krOezrn
"""

import os
import re
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras.preprocessing import image
import cv2
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore
from PIL import Image
import base64
import io
import urllib.request

## Global variable
model = None  #model
db = None
image_path = ""
datee = ""
file_nama = ""
value = ""

# Download model file from cloud storage bucket
def download_model_file():

    from google.cloud import storage

    # Model Bucket details
    BUCKET_NAME        = "gencarabucket"
    PROJECT_ID         = "gencaraapp"
    GCS_MODEL_FILE     = "model_weight.h5"

    # Initialise a client
    client   = storage.Client(PROJECT_ID)

    # Create a bucket object for our bucket
    bucket   = client.get_bucket(BUCKET_NAME)

    # Create a blob object from the filepath
    blob     = bucket.blob(GCS_MODEL_FILE)

    folder = '/tmp/'
    if not os.path.exists(folder):
        os.makedirs(folder)
    # Download the file to a destination
    blob.download_to_filename(folder + "model.h5")

def download_image(event, context):

    from google.cloud import storage

    file = event
    # Model Bucket details
    BUCKET_NAME        = "gencara-user-input"
    PROJECT_ID         = "gencaraapp"
    GCS_IMAGE_FILE     = file['name']

    # Initialise a client
    client   = storage.Client(PROJECT_ID)

    # Create a bucket object for our bucket
    bucket   = client.get_bucket(BUCKET_NAME)

    # Create a blob object from the filepath
    blob     = bucket.blob(GCS_IMAGE_FILE)

    folder = '/tmp/'
    if not os.path.exists(folder):
        os.makedirs(folder)
    # Download the file to a destination
    global image_path
    image_path = folder + GCS_IMAGE_FILE
    blob.download_to_filename(image_path)

    #adding function split name
    global file_nama
    global datee
    file_nama = file['name']
    datee = file_nama.split('-') #use datee[-2]

def preprocess_image(image, target_size):
    if image.mode != "RGB":
        image = image.convert("RGB")
    image = image.resize(target_size)
    image = np.array(image)
    image = np.expand_dims(image, axis=0)
    image = image / 255.0
    return image

def sl_predict(event, context):

    global model, db, image_path, datee, file_nama, value
    # Map label indeks ke abjad
    label_map = {i: chr(65 + i) for i in range(26)}

    # Get JSON data from request
    message = urllib.request.Request.get_json(force=True)
    encoded = message['image']

    # Decode base64 encoded image
    decoded = base64.b64decode(encoded)

    # Open image using PIL
    img = Image.open(io.BytesIO(decoded))

    # Save image locally (optional, depends on your implementation)
    folder = '/tmp/'
    if not os.path.exists(folder):
        os.makedirs(folder)

    global image_path
    image_path = folder + "input_image.jpg"
    img.save(image_path)

    # Perform prediction

    # Deploy model locally if not loaded
    if model is None:
        download_model_file()
        model = tf.keras.models.load_model('/tmp/model.h5')

    # Initialize Firestore if not initialized
    if db is None:
        cred = credentials.ApplicationDefault()
        firebase_admin.initialize_app(cred, {
            'projectId': 'gencaraapp',
        })
        db = firestore.client()

    # Process the image (optional preprocessing step)
    processed_image = preprocess_image(img, target_size=(64, 64))

    # Perform prediction using loaded model
    prediction = model.predict(processed_image).tolist()
    predicted_label_index = np.argmax(prediction, axis=1)[0]
    predicted_abjad = label_map[predicted_label_index]  # Assuming label_map is defined somewhere

    # Update Firestore with prediction result
    doc_ref = db.collection(u'sign-language').document(datee[-2])
    doc_ref.set({
        file_nama.strip('.jpg'): predicted_abjad
    }, merge=True)

    # Print and return prediction
    print(file_nama + '\n')
    print(datee[-2] + '\n')
    print(predicted_abjad + '\n')

    return predicted_abjad